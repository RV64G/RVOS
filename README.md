# RVOS

A simple RISC-V operating system implementation.

## 项目状态与问题记录

### 已解决的问题

#### 1. 上下文切换问题（✅ 已修复）
**问题描述**: 任务切换时寄存器没有正确保存和恢复，导致任务无法正常运行。

**解决方案**: 
- 修复了 `entry.S` 中的上下文切换逻辑，确保所有寄存器正确保存和恢复
- 确保栈指针16字节对齐，符合RISC-V ABI要求
- 修复了 `task.c` 中任务创建时的栈设置

**关键修改文件**: `entry.S`, `task.c`

**验证**: 系统调用和基本任务切换现在工作正常

#### 2. 任务调度问题（✅ 已修复）
**问题描述**: 任务调度器状态管理不正确，导致任务无法正常调度。

**解决方案**:
- 改进了 `schedule()` 函数中的任务状态管理
- 修复了任务退出逻辑，确保EXITED状态的任务被正确跳过
- 添加了详细的调试信息来跟踪调度过程
- 实现了优先级调度和轮转调度机制

**关键修改文件**: `task.c`

**验证**: 协作式多任务调度工作正常，前5个任务能够正确执行

#### 3. 系统调用问题（✅ 已修复）
**问题描述**: 系统调用在某些情况下会导致系统崩溃。

**解决方案**:
- 通过修复上下文切换和栈对齐问题，系统调用现在能正常工作
- `test_syscalls_task` 现在可以正常执行并获取hart id

**验证**: `test_syscalls_task` 成功执行并返回正确的hart id

#### 4. 定时器中断配置（✅ 已修复）
**问题描述**: 定时器中断没有正确配置，导致抢占式调度无法触发。

**解决方案**:
- 在 `timer_init()` 中启用machine-mode全局中断 (`MSTATUS_MIE`)
- 修复定时器间隔设置，使用更短的间隔便于调试
- 确保定时器能够持续触发中断

**关键修改文件**: `timer.c`

**验证**: 定时器中断现在能够正常触发

### 当前未解决的问题

#### ❌ 主要问题: 抢占式调度失效

**问题描述**: 
当系统运行到 Task 5 (just_while)——一个包含无限循环的任务时，系统会卡死。该任务永远不会主动调用 `task_yield()` 让出CPU，而抢占式调度机制没有正常工作。

**现象**:
- 系统能正常启动并执行前面的任务（task 0-4）
- 到达 just_while 任务后系统完全卡死，没有任何输出
- 定时器中断能够触发，但无法有效进行任务切换

**详细运行日志**:
```
[DEBUG] schedule() called, current_task_id=4
[DEBUG] Switching to task 5 (func=0x8000416c)
```
之后系统完全卡死，没有进一步输出。

**已尝试的解决方案**:

1. **软件中断方案**:
   ```c
   // 在timer_handler()中每5个tick触发软件中断
   if (_tick % 5 == 0) {
       int id = r_mhartid();
       *(uint32_t *)CLINT_MSIP(id) = 1;
   }
   ```
   **结果**: 软件中断能触发，但schedule()调用后仍然卡死

2. **直接调度方案**:
   ```c
   // 在timer_handler()中直接调用schedule()
   if (_tick % 10 == 0) {
       printf("Preemptive scheduling at tick %d\n", _tick);
       schedule();
   }
   ```
   **结果**: 仍然卡死，可能存在栈溢出或中断上下文问题

3. **定时器回调方案**:
   - 尝试使用定时器回调函数调用调度器
   **结果**: 函数签名匹配问题，效果与直接调用类似

**技术分析**:

- **中断设置**: ✅ 已正确配置MIE和MSTATUS寄存器
- **定时器配置**: ✅ 使用CLINT定时器，间隔设置正确
- **调度函数**: ✅ `schedule()` 函数在协作式调度中工作正常
- **上下文切换**: ✅ 基本的上下文切换机制已验证工作

**可能的根本原因**:

1. **中断上下文问题**: 在定时器中断处理程序中调用 `schedule()` 可能导致上下文切换逻辑混乱
2. **栈管理问题**: 从中断上下文进行任务切换时栈状态可能不正确
3. **寄存器保存问题**: 中断发生时的寄存器状态可能没有正确保存到任务上下文中
4. **RISC-V特定问题**: 可能存在RISC-V架构特定的中断和上下文切换交互问题

### 系统架构说明

**核心模块**:
- `entry.S`: 汇编级别的上下文切换和中断处理（✅ 已修复）
- `task.c`: 任务管理和调度器（✅ 协作式调度已修复，❌ 抢占式调度未解决）
- `timer.c`: 定时器管理和中断处理（✅ 基本功能已修复）
- `trap.c`: 异常和中断处理路由（✅ 已修复）

**关键数据结构**:
- `struct context`: 保存任务的CPU寄存器状态（✅ 已修复）
- `task_t`: 任务控制块，包含状态、栈指针、函数指针等（✅ 已修复）

**调度机制**:
- ✅ 协作式调度: 通过 `task_yield()` 主动让出CPU
- ✅ 优先级调度: 支持基于优先级的任务选择
- ✅ 轮转调度: 同优先级任务间的轮转
- ❌ 抢占式调度: 定时器中断触发的强制任务切换

### 编译和运行

```bash
cd OS
make clean && make
cd ..
qemu-system-riscv32 -nographic -machine virt -bios none -kernel OS/build/os.bin
```

### 测试用例状态

1. ✅ `test_syscalls_task`: 系统调用测试 - **通过**
2. ✅ `user_task0`, `user_task1`: 协作式任务 - **通过**
3. ✅ `user_task(2)`, `user_task(3)`: 有限运行任务 - **通过**
4. ❌ `just_while`: 无限循环任务 - **卡死系统**

### 技术贡献

本项目成功实现了：
1. 完整的RISC-V上下文切换机制
2. 优先级协作式多任务调度
3. 系统调用处理
4. 定时器中断处理
5. 基本的任务生命周期管理

### 进一步工作建议

1. **深入研究RISC-V中断机制**: 分析中断上下文与任务上下文的交互
2. **重新设计抢占机制**: 考虑使用更安全的抢占式调度实现
3. **使用GDB调试**: 在QEMU中使用GDB进行更深入的调试分析
4. **参考其他实现**: 研究xv6-riscv等成熟项目的抢占式调度实现
5. **简化测试**: 创建更简单的抢占测试用例来隔离问题

### 相关文档

- `ISSUES.md`: 详细技术问题记录
- 源代码注释: 包含详细的修复说明和调试信息

---

*项目状态: 协作式多任务已完成，抢占式调度待解决*  
*最后更新: 2025年6月5日*